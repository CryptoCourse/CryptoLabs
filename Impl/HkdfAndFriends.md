Стойкость симметричный криптопримитивов с ключом основывается на предположении о случайности данного ключа. При этом предполагается, что ключ был получен случайно из равномерно распределнного множества ключей достаточной размерности.

Иными словами, стойкость симметричной криптосистемы требует максимальной энтропии ключа.

В реальности однако, большинство источников случайности (энтропии) не обладают равномерным распределением, и ключевой материал, полученный из данных источников, не может быть использованы напрямую в качестве симметричных ключей.

Если же необходимо получить симметричный ключ на основе такого ключевого материала используют так называемые Функции Выработки Ключа (Key Derivation Functions, KDF).

В данной работе рассматривается применение KDF к неравномерно распределенному источнику энтропии с целью выработки равномерно распределённых симметричных ключей.

## HKDF

KDF состоит их двух подфункций: извлечения (extract) и расширения (expand).

Функция извлечения получает равномерно распределённый случайный ключ, используя неравномерно распределённый ключевой материал.

Функция расширения формирует последовательность ключей на основе одного случайного равномерно распределённого ключа.

HKDF - KDF на основе кода аутентичности HMAC. 

Извлечение: PRK <- HMAC(XTS, SKM)
Расширение: K_i <- HMAC(PRK, CTX, i)

1. На основе файла weather.json построить гистограммы температуры, влажности, скорости ветра, облачности и озонового слоя. Выбрать одну из указанных величин (или комбинацию величин) в качестве ключевого материала.

2. Реализовать HMAC на основе хэш функции SHA-256. В качестве SHA-256 использовать криптографически стойкую реализацию из общераспространённой библиотеке на вашем языке.

3. Интерфейс функции: byte[] HmacSha256(byte[] key, byte[] data)

4. Реализовать функцию HkdfExtract, которая на основе HMAC, в качестве псевдослучайной функции, соли XTS и ключевого материала SKM) получает ключ PRK для псевдослучайной функции.

Интерфейс фукнции: byte[] HkdfExtract(byte[] XTS, byte[] SKM)

5. Реализовать функцию HkdfExpand, которая на основе псевдослучайной функции HMAC, её ключа PRK, контекста CTX и счетчика i получает i-й симметричный ключ.

Интерфейс фукнции: byte[] HkdfExpand(byte[] PRK, byte[] CTX, int i)

6. Для i =1..1000 получить 1000 симметричных ключей длины 256 бит на основе HKDF, где data - выбранные данные на шаге 1.
В качестве соли использовать случаную равномерно распределённую величину, полученную и использованием криптографического Г(П)СЧ, реализованного в вашем языке. 

CTX <- "Ваше имя"
XTS <- Crypto.Random()
PRK <- HkdfExtract(XTS, data)
K_i = HkdfExpand(PRK, CTX, i)

7. Убедиться в равномерной распределённости первых 5 бит ключей, построив гистограмму.

## PBKDF2

HKDF позволяет получить равномерные данные из неравномерно распределённого источника энтропии. Однако если источник обладает низкой энтропией (например пароли)
необходимо использовать PBKDF2, основным изменением которого является медленное хэширование, необходимое для увеличения сложности перебора ключевого материала.
P - пароль пользователя (ключевой материал), S - соль, len = |K|/|HMAC|, |K| - размер ключа, |HMAC| - размер выхода HMAC.

U_1 = HMAC(P, S||i)
U_c = HMAC(U_{c-1})
F(P,S, c, i) = U_1 + .... + U_c, '+' = XOR
T_i = F(P, S, c, i)
K = T_1 || T_len

1. На основе файла passwords.json построить гистрограмму распределения первых 5 бит паролей (кодировка ASCII).
2. Реализовать PBKDF2 с использованием HMAC в качестве PRF, с использованием случайного seed. Число итераций 10000.
3. Получить симметричный ключ для каждого пароля.
4. Убедиться в равномерной распределённости первых 5 бит ключей, построив гистограмму.