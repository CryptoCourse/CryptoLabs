В рамках данной работы необходимо реализовать протокол sigma, используя в качестве примитивов схемы ECDSA в качестве схемы
формирования электронных подписей, ECDH - в качестве схемы формирования общего секрета, AES-CTR - в качестве алгоритма шифрования, HMAC-SHA256 в качестве PRF и MAC.

Пусть ECDSA состоит из тройки алгоритмов - `(GEN, SIGN_X(m), VER_X(m, s))`, где

`GEN` - функция генерации ключевой пары 

`SIGN_X(m)` - функция формирования подписи для сообщения `m` с использованием закрытого ключа пользователя `X`

`VER_X(m, s)` - функция проверки подписи `s` для сообщения `m` с использованием открытого ключа пользователя `X`.

Пусть ECDH состоит из пары алгоритмов - `(GEN, GET(X_SK, Y_PK))`, где

`GEN` - функция генерации ключевой пары 

`GET(X_SK, Y_PK)` - функция выработки общего секрета из открытого ключа `Y` и закрытого ключа `X`

#### 0. Предварительный обмен ключами (выполняется вне протокола)
```
A: (ECDSA_PK_A, ECDSA_SK_A) <- ECDSA.GEN; ECDSA_PK_A -> B
B: (ECDSA_PK_B, ECDSA_SK_B) <- ECDSA.GEN; ECDSA_PK_B -> A
```

#### 1. Описание протокола Sigma.

```
A: (DH_PK_A, DH_SK_A) <- ECDH.GEN; r_A <-^r {0,1}^R; (DH_PK_A, r_A) -> B

B: (DH_PK_B, DH_SK_B) <- ECDH.GEN; r_B <-^r {0,1}^R; (k_m, k_e) <- PRF_(r_A||r_B)(ECDH.GET(DH_SK_B, DH_PK_A)); (DH_PK_A, B, ECDSA.SIGN_B(DH_PK_A, DH_PK_B), MAC_k_m(B)) -> A

A: (k_m, k_e) <- PRF_(r_A||r_B)(ECDH.GET(DH_SK_A, DH_PK_B)); (A ECDSA.SIGN_A(DH_PK_A, DH_PK_B), MAC_k_m(A)) -> B
```

#### 2. Отправка зашифрованных данных

```
A: c <- AES_k_e(m); (c, MAC_k_m(c)) -> B
```

#### Описание лабораторной работы

1. Реализовать протокол Sigma, используя встроенные средства языка, получив общие ключи для аутентификации и шифрования.
2. Использовать полученные ключи для аутентифицированного шифрования AES-CRT-Then-Hmac для обеспечения аутентичности и секретности данных.
3. Проверить аутентичность полученных данных на стороне получателя и расшифровать сообщение.


#### Дополнительные ссылки
https://webee.technion.ac.il/~hugo/sigma-pdf.pdf (стр 17-18)

